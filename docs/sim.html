<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>LHRP vs Dijkstra / A* / BFS Vergleich</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background: #0f1724;
            color: #e6eef6;
            padding: 20px;
        }

        h1 {
            color: #38bdf8;
            margin: 0 0 12px 0
        }

        label {
            display: block;
            margin-top: 8px
        }

        input,
        button,
        select {
            padding: 8px;
            margin: 6px 0;
            border-radius: 6px;
            border: 1px solid #444;
            background: #081025;
            color: #e6eef6;
        }

        button {
            background: #38bdf8;
            border: none;
            font-weight: bold;
            cursor: pointer
        }

        pre {
            background: #0b1220;
            padding: 15px;
            border-radius: 8px;
            overflow: auto;
            white-space: pre-wrap;
            word-break: break-word
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px
        }

        @media (max-width:800px) {
            .grid {
                grid-template-columns: 1fr
            }
        }

        .alg-list {
            display: flex;
            gap: 8px;
            flex-wrap: wrap
        }

        .checkbox {
            display: flex;
            align-items: center;
            gap: 6px
        }

        .small {
            font-size: 0.9em;
            color: #b7d8ee
        }
    </style>
</head>

<body>

    <h1>LHRP vs Dijkstra / A* / BFS — Vergleich</h1>

    <div class="grid">
        <div>
            <label>Trials (Anzahl Zufallsrouten):</label>
            <input id="trials" type="number" value="2000" min="1">

            <label>Knotenanzahl (max):</label>
            <input id="nodes" type="number" value="200" min="2">

            <label>Extra Verbindungen (Shortcuts):</label>
            <input id="extras" type="number" value="60" min="0">

            <label>Max Baumtiefe:</label>
            <input id="depth" type="number" value="6" min="1">

            <label>Max Hops (für LHRP / A* Routing Abbruch):</label>
            <input id="maxhops" type="number" value="300" min="1">

            <label>Algorithmen auswählen:</label>
            <div class="alg-list">
                <label class="checkbox"><input class="alg" type="checkbox" value="lhrp" checked> Normal LHRP</label>
                <label class="checkbox"><input class="alg" type="checkbox" value="bfs" checked> BFS (kürzester Pfad,
                    ungewichtet)</label>
                <label class="checkbox"><input class="alg" type="checkbox" value="dijkstra" checked> Dijkstra
                    (einheitliche Kanten = BFS)</label>
                <label class="checkbox"><input class="alg" type="checkbox" value="astar" checked> A*
                    (Präfix-Heuristik)</label>
            </div>

            <button onclick="runCompare()">Vergleich starten</button>
        </div>

        <div>
            <h2>Ergebnis</h2>
            <pre id="output">Kein Lauf durchgeführt.</pre>
        </div>
    </div>

    <script>
        /*
          Implementierung:
          - zufälliger Baum mit zusätzlichen Shortcuts
          - Adressen: arrays von small integers (wie im C++ Beispiel)
          - Normal LHRP: Implementiert nach dem C++ Snippet, nur eine Variante
          - BFS: ungewichteter kürzester Pfad
          - Dijkstra: hier mit Einheit-Gewichten (gleich BFS), implementiert mit PriorityQueue
          - A*: benutzt eine praktische Präfix-Heuristik (nicht garantiert admissible in presence of shortcuts),
                 kann dennoch Aufschluss über zielgerichtete Suche geben.
        */

        // ----------------- Hilfs: Address / Match (gemäß C++ Code) -----------------

        function prefixMatch(connectionAddr, pocketAddr) {
            const minLen = Math.min(connectionAddr.length, pocketAddr.length);
            let positive = 0;
            while (positive < minLen && connectionAddr[positive] === pocketAddr[positive]) positive++;
            const negative = connectionAddr.length - positive;
            return { positive, negative };
        }

        function matchIndex(m) {
            return m.positive - m.negative;
        }

        function eqAddr(a1, a2) {
            if (a1.length !== a2.length) return false;
            for (let i = 0; i < a1.length; i++) if (a1[i] !== a2[i]) return false;
            return true;
        }

        function isChildren(other, you) {
            if (other.length <= you.length) return false;
            for (let i = 0; i < you.length; i++) if (other[i] !== you[i]) return false;
            return true;
        }

        // ----------------- Graphaufbau -----------------

        function buildRandomGraph(nodeCount, extraCount, maxDepth) {
            const nodes = [];
            // root address [0]
            const root = { id: 0, address: [0], parent: null, children: [], extraConnections: [] };
            nodes.push(root);

            for (let i = 1; i < nodeCount; i++) {
                const available = nodes.filter(n => n.address.length < maxDepth && n.children.length < 4);
                if (!available.length) break;
                const parent = available[Math.floor(Math.random() * available.length)];
                const address = parent.address.concat([parent.children.length]);
                const node = { id: i, address, parent: parent.id, children: [], extraConnections: [] };
                parent.children.push(i);
                nodes.push(node);
            }

            // add extra (bidirectional) shortcuts, prefer level-different pairs
            for (let i = 0; i < extraCount; i++) {
                let tries = 0;
                while (tries++ < 400) {
                    const a = Math.floor(Math.random() * nodes.length);
                    const b = Math.floor(Math.random() * nodes.length);
                    if (a === b) continue;
                    const A = nodes[a], B = nodes[b];
                    if (A.parent === b || B.parent === a) continue;
                    if (A.children.includes(b) || B.children.includes(a)) continue;
                    if (A.extraConnections.includes(b)) continue;
                    if (Math.abs(A.address.length - B.address.length) < 2) continue;
                    A.extraConnections.push(b);
                    B.extraConnections.push(a);
                    break;
                }
            }

            // prepare adjacency list
            const adj = new Array(nodes.length).fill(0).map(() => []);
            nodes.forEach(n => {
                if (n.parent !== null) adj[n.id].push(n.parent);
                n.children.forEach(c => adj[n.id].push(c));
                n.extraConnections.forEach(e => adj[n.id].push(e));
            });

            // For LHRP send, prepare per-node connections (address + to)
            nodes.forEach(n => {
                n.connections = [];
                if (n.parent !== null) n.connections.push({ address: nodes[n.parent].address.slice(), to: n.parent });
                n.children.forEach(c => n.connections.push({ address: nodes[c].address.slice(), to: c }));
                n.extraConnections.forEach(e => n.connections.push({ address: nodes[e].address.slice(), to: e }));
            });

            return { nodes, adj };
        }

        // ----------------- BFS (unweighted shortest path) -----------------

        function bfs(adj, start, goal) {
            const visited = new Array(adj.length).fill(false);
            const parent = new Array(adj.length).fill(-1);
            const q = [start];
            visited[start] = true;
            let head = 0;
            let ops = 0;
            while (head < q.length) {
                const u = q[head++];
                if (u === goal) break;
                for (const v of adj[u]) {
                    ops++;
                    if (!visited[v]) {
                        visited[v] = true;
                        parent[v] = u;
                        q.push(v);
                    }
                }
            }
            if (!visited[goal]) return { success: false, ops };
            let hops = 0;
            for (let cur = goal; cur !== start; cur = parent[cur]) hops++;
            return { success: true, hops, ops };
        }

        // ----------------- Dijkstra (here with unit weights) -----------------

        class MinPQ {
            constructor() { this._arr = []; }
            push(item, prio) { this._arr.push({ item, prio }); this._arr.sort((a, b) => a.prio - b.prio); }
            pop() { return this._arr.length ? this._arr.shift().item : null; }
            isEmpty() { return this._arr.length === 0; }
        }

        function dijkstra(adj, start, goal) {
            const n = adj.length;
            const dist = new Array(n).fill(Infinity);
            const prev = new Array(n).fill(-1);
            const pq = new MinPQ();
            let ops = 0;

            dist[start] = 0;
            pq.push(start, 0);

            while (!pq.isEmpty()) {
                const u = pq.pop();
                if (u === goal) break;
                for (const v of adj[u]) {
                    ops++;
                    const nd = dist[u] + 1; // unit weight
                    if (nd < dist[v]) {
                        dist[v] = nd;
                        prev[v] = u;
                        pq.push(v, nd);
                    }
                }
            }
            if (!isFinite(dist[goal])) return { success: false, ops };
            let hops = 0;
            for (let cur = goal; cur !== start; cur = prev[cur]) hops++;
            return { success: true, hops, ops };
        }

        // ----------------- A* (heuristic: negative common-prefix based) -----------------
        // Hinweis: Die Präfix-Heuristik ist praktisch, aber in presence of shortcuts nicht notwendigerweise admissible.
        // Für Tests ist sie nützlich, erwartet nicht strikt optimale Ergebnisse in allen Graphen.

        function prefixLength(a, b) {
            const m = Math.min(a.length, b.length);
            let i = 0;
            while (i < m && a[i] === b[i]) i++;
            return i;
        }

        function aStar(adj, nodes, start, goal) {
            // g = cost from start, h = heuristic: remaining depth estimate = target.level - commonPrefix
            const n = adj.length;
            const g = new Array(n).fill(Infinity);
            const f = new Array(n).fill(Infinity);
            const prev = new Array(n).fill(-1);
            const open = new MinPQ();
            let ops = 0;

            function heuristic(u) {
                const common = prefixLength(nodes[u].address, nodes[goal].address);
                const estimate = Math.max(0, nodes[goal].address.length - common);
                return estimate;
            }

            g[start] = 0;
            f[start] = heuristic(start);
            open.push(start, f[start]);

            while (!open.isEmpty()) {
                const u = open.pop();
                if (u === goal) break;
                for (const v of adj[u]) {
                    ops++;
                    const tentative_g = g[u] + 1;
                    if (tentative_g < g[v]) {
                        g[v] = tentative_g;
                        prev[v] = u;
                        f[v] = g[v] + heuristic(v);
                        open.push(v, f[v]);
                    }
                }
            }

            if (!isFinite(g[goal])) return { success: false, ops };
            let hops = 0;
            for (let cur = goal; cur !== start; cur = prev[cur]) hops++;
            return { success: true, hops, ops };
        }

        // ----------------- Normal LHRP (gemäß C++ snippet) -----------------

        // send at node: choose best connection according to matchIndex(match(conn.address, target.address))
        // tie-breaker: longer conn.address wins. If target is a direct child of current node (target in subtree),
        // and chosen connection is not a child (i.e., not isChildren(best.address, you)), then fail (do not forward).
        // Return neighbor id to forward to, or null for failure.
        function nodeSend_LHRP(node, nodes, pocketAddress) {
            if (!node.connections || node.connections.length === 0) return null;
            if (eqAddr(node.address, pocketAddress)) return null; // already at destination (deliver locally)

            // choose best
            let best = node.connections[0];
            let bestIdx = matchIndex(prefixMatch(best.address, pocketAddress));
            let bestLen = best.address.length;

            const directChild = isChildren(pocketAddress, node.address);

            for (let i = 1; i < node.connections.length; i++) {
                const c = node.connections[i];
                const idx = matchIndex(prefixMatch(c.address, pocketAddress));
                const len = c.address.length;
                if (idx > bestIdx || (idx === bestIdx && len > bestLen)) {
                    best = c;
                    bestIdx = idx;
                    bestLen = len;
                }
            }

            if (directChild && !isChildren(best.address, node.address)) return null;

            return best.to;
        }

        // route using LHRP: simulate forwarding until reach goal or fail
        function lhrpRoute(nodes, adj, start, goal, maxHops) {
            let current = start;
            const visited = new Set();
            let hops = 0, ops = 0;

            while (current !== goal) {
                if (visited.has(current)) return { success: false, hops: null, ops };
                visited.add(current);
                const node = nodes[current];
                const next = nodeSend_LHRP(node, nodes, nodes[goal].address);
                // count ops roughly as number of connection comparisons inside nodeSend: connections length
                ops += node.connections ? node.connections.length : 0;

                if (next === null) return { success: false, hops: null, ops };
                current = next;
                hops++;
                if (hops > maxHops) return { success: false, hops: null, ops };
            }
            return { success: true, hops, ops };
        }

        // ----------------- Vergleichsroutine -----------------

        function vergleiche(trials, nodeCount, extra, maxDepth, selectedAlgs, maxHops) {
            const { nodes, adj } = buildRandomGraph(nodeCount, extra, maxDepth);

            const stats = {
                network: { nodes: nodes.length, extraEdges: extra, maxDepth },
                trials,
                algorithms: {}
            };

            // init stats for each algorithm
            for (const alg of selectedAlgs) {
                stats.algorithms[alg] = { successCount: 0, totalHop: 0, totalOps: 0 };
            }

            for (let i = 0; i < trials; i++) {
                let a = Math.floor(Math.random() * nodes.length);
                let b = Math.floor(Math.random() * nodes.length);
                if (a === b) { i--; continue; }

                // BFS
                if (selectedAlgs.includes('bfs')) {
                    const r = bfs(adj, a, b);
                    stats.algorithms['bfs'].totalOps += r.ops;
                    if (r.success) { stats.algorithms['bfs'].successCount++; stats.algorithms['bfs'].totalHop += r.hops; }
                }

                // Dijkstra
                if (selectedAlgs.includes('dijkstra')) {
                    const r = dijkstra(adj, a, b);
                    stats.algorithms['dijkstra'].totalOps += r.ops;
                    if (r.success) { stats.algorithms['dijkstra'].successCount++; stats.algorithms['dijkstra'].totalHop += r.hops; }
                }

                // A*
                if (selectedAlgs.includes('astar')) {
                    const r = aStar(adj, nodes, a, b);
                    stats.algorithms['astar'].totalOps += r.ops;
                    if (r.success) { stats.algorithms['astar'].successCount++; stats.algorithms['astar'].totalHop += r.hops; }
                }

                // LHRP (single, normal)
                if (selectedAlgs.includes('lhrp')) {
                    const r = lhrpRoute(nodes, adj, a, b, maxHops);
                    stats.algorithms['lhrp'].totalOps += r.ops;
                    if (r.success) { stats.algorithms['lhrp'].successCount++; stats.algorithms['lhrp'].totalHop += r.hops; }
                }
            }

            // finalize metrics
            const out = { network: stats.network, trials: stats.trials, algorithms: {} };
            for (const alg of selectedAlgs) {
                const s = stats.algorithms[alg];
                out.algorithms[alg] = {
                    successRate: s.successCount / trials,
                    avgHop: s.successCount ? (s.totalHop / s.successCount) : null,
                    avgOps: s.totalOps / trials
                };
            }

            // add basic graph diagnostics
            const nodeDegrees = adj.map(a => a.length);
            out.network.avgDegree = nodeDegrees.reduce((a, b) => a + b, 0) / nodeDegrees.length;

            return out;
        }

        // ----------------- UI / Runner -----------------

        function runCompare() {
            const trials = Math.max(1, parseInt(document.getElementById("trials").value) || 2000);
            const nodes = Math.max(2, parseInt(document.getElementById("nodes").value) || 200);
            const extras = Math.max(0, parseInt(document.getElementById("extras").value) || 60);
            const depth = Math.max(1, parseInt(document.getElementById("depth").value) || 6);
            const maxhops = Math.max(1, parseInt(document.getElementById("maxhops").value) || 300);

            const checks = Array.from(document.querySelectorAll('.alg')).filter(c => c.checked).map(c => c.value);
            if (!checks.length) { document.getElementById("output").textContent = "Bitte mindestens einen Algorithmus auswählen."; return; }

            document.getElementById("output").textContent = "Berechnung läuft... (UI bleibt responsiv)";

            // slight timeout for UI refresh
            setTimeout(() => {
                try {
                    const start = performance.now();
                    const res = vergleiche(trials, nodes, extras, depth, checks, maxhops);
                    const duration = ((performance.now() - start) / 1000).toFixed(2);
                    res.duration_seconds = parseFloat(duration);
                    document.getElementById("output").textContent = JSON.stringify(res, null, 2);
                } catch (e) {
                    document.getElementById("output").textContent = "Fehler: " + e.toString();
                }
            }, 30);
        }

    </script>

</body>

</html>