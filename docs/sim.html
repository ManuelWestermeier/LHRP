<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Statistik: Randomisierte Bäume — LHRP vs Dijkstra / A* / BFS</title>
    <style>
        :root {
            --bg: #0f1724;
            --card: #0b1220;
            --muted: #b7d8ee;
            --accent: #38bdf8;
            --panel: #081025;
            --input-bg: #07101a;
            --border: #223047;
        }

        html,
        body {
            height: 100%
        }

        body {
            font-family: Inter, Arial, sans-serif;
            background: var(--bg);
            color: #e6eef6;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }

        .container {
            max-width: 1100px;
            margin: 0 auto
        }

        .header {
            display: flex;
            gap: 16px;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px
        }

        h1 {
            font-size: 1.15rem;
            color: var(--accent);
            margin: 0
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(2, minmax(220px, 1fr));
            gap: 12px
        }

        .panel {
            background: var(--card);
            padding: 12px;
            border-radius: 10px;
            border: 1px solid var(--border)
        }

        label {
            display: block;
            font-size: 0.85rem;
            color: var(--muted);
            margin-bottom: 6px
        }

        .inputrow {
            display: flex;
            gap: 8px;
            align-items: center
        }

        input[type="number"],
        select,
        button {
            padding: 8px 10px;
            border-radius: 8px;
            border: 1px solid var(--border);
            background: var(--input-bg);
            color: inherit;
            font-size: 0.95rem;
        }

        button {
            background: var(--accent);
            border: none;
            color: #022;
            cursor: pointer;
            font-weight: 600
        }

        .small {
            font-size: 0.86rem;
            color: var(--muted)
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr 420px;
            gap: 16px;
            margin-top: 14px
        }

        @media (max-width:980px) {
            .grid {
                grid-template-columns: 1fr
            }
        }

        .alg-list {
            display: flex;
            gap: 8px;
            flex-wrap: wrap
        }

        .checkbox {
            display: flex;
            align-items: center;
            gap: 8px
        }

        .output {
            white-space: pre-wrap;
            word-break: break-word;
            font-family: monospace;
            background: var(--panel);
            padding: 12px;
            border-radius: 8px;
            border: 1px solid var(--border);
            max-height: 520px;
            overflow: auto
        }

        .footer {
            margin-top: 14px;
            font-size: 0.8rem;
            color: var(--muted)
        }

        .progress {
            height: 8px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 6px;
            overflow: hidden;
            margin-top: 8px
        }

        .progress>i {
            display: block;
            height: 100%;
            background: linear-gradient(90deg, var(--accent), #7dd3fc);
            width: 0%
        }

        .small-muted {
            font-size: 0.82rem;
            color: var(--muted);
            margin-top: 6px
        }
    </style>
</head>

<body>

    <div class="container">
        <div class="header">
            <h1>Statistik: Randomisierte Bäume — LHRP vs Dijkstra / A* / BFS</h1>
            <div class="small">Ausgabe: JSON im gewünschten Format</div>
        </div>

        <div class="controls panel">
            <div style="display:flex;gap:12px;align-items:center;justify-content:space-between">
                <div>
                    <label>Trials (Anzahl zufälliger Routen)</label>
                    <input id="trials" type="number" value="2000" min="1">
                </div>
                <div>
                    <label>Knotenanzahl (max)</label>
                    <input id="nodes" type="number" value="200" min="2">
                </div>
            </div>

            <div style="display:flex;gap:12px;margin-top:10px">
                <div style="flex:1">
                    <label>Extra Verbindungen (Shortcuts)</label>
                    <input id="extras" type="number" value="60" min="0">
                </div>
                <div style="flex:1">
                    <label>Max Baumtiefe</label>
                    <input id="depth" type="number" value="6" min="1">
                </div>
            </div>

            <div style="display:flex;gap:12px;margin-top:10px">
                <div style="flex:1">
                    <label>Max Hops (LHRP Abbruch)</label>
                    <input id="maxhops" type="number" value="300" min="1">
                </div>
                <div style="flex:1">
                    <label>Random Seed (optional)</label>
                    <input id="seed" type="number" placeholder="leer = Math.random()">
                </div>
            </div>

            <label style="margin-top:10px">Algorithmen auswählen</label>
            <div class="alg-list">
                <label class="checkbox"><input class="alg" type="checkbox" value="lhrp" checked> Normal LHRP</label>
                <label class="checkbox"><input class="alg" type="checkbox" value="bfs" checked> BFS</label>
                <label class="checkbox"><input class="alg" type="checkbox" value="dijkstra" checked> Dijkstra</label>
                <label class="checkbox"><input class="alg" type="checkbox" value="astar" checked> A*</label>
            </div>

            <div style="display:flex;gap:8px;margin-top:12px;align-items:center">
                <button id="runBtn">Vergleich starten</button>
                <div style="flex:1"></div>
                <button id="exportCSV"
                    style="background:transparent;border:1px solid var(--border);color:var(--muted)">Export CSV</button>
            </div>

            <div class="small-muted">Hinweis: Seed ermöglicht Reproduzierbarkeit.</div>
            <div class="progress" style="display:none"><i></i></div>
        </div>

        <div class="grid">
            <div class="panel">
                <h3 style="margin:0 0 8px 0">Ergebnis (JSON)</h3>
                <div id="summary" class="output">{ "network": { "nodes": 0 }, "trials": 0, "algorithms": {},
                    "duration_seconds": 0 }</div>
            </div>

            <div class="panel">
                <h3 style="margin:0 0 8px 0">Detail- & Export-Tools</h3>
                <div style="display:flex;flex-direction:column;gap:8px">
                    <div class="small">CSV: pro Trial Start/Goal + pro Algorithmus success,hops,ops</div>
                    <button id="showRaw">Rohdaten (JSON)</button>
                    <button id="showHist">Hops-Histogramme (Text)</button>
                </div>
                <div style="margin-top:10px" id="extraOutput" class="output" aria-live="polite"></div>
            </div>
        </div>

        <div class="footer small-muted">
            JavaScript-Client simuliert zufällige Baumstruktur + Shortcuts; LHRP gemäß C++-Snippet.
        </div>
    </div>

    <script>
        /* RNG mit Seed (mulberry32) */
        function mkRNG(seed) {
            if (seed == null) return Math.random;
            let t = Number(seed) >>> 0;
            return function () {
                t += 0x6D2B79F5;
                var r = Math.imul(t ^ t >>> 15, 1 | t);
                r ^= r + Math.imul(r ^ r >>> 7, 61 | r);
                return ((r ^ r >>> 14) >>> 0) / 4294967296;
            };
        }

        /* Address / Match helpers */
        function prefixMatch(connectionAddr, pocketAddr) {
            const minLen = Math.min(connectionAddr.length, pocketAddr.length);
            let positive = 0;
            while (positive < minLen && connectionAddr[positive] === pocketAddr[positive]) positive++;
            const negative = connectionAddr.length - positive;
            return { positive, negative };
        }
        function matchIndex(m) { return m.positive - m.negative; }
        function eqAddr(a1, a2) {
            if (a1.length !== a2.length) return false;
            for (let i = 0; i < a1.length; i++) if (a1[i] !== a2[i]) return false;
            return true;
        }
        function isChildren(other, you) {
            if (other.length <= you.length) return false;
            for (let i = 0; i < you.length; i++) if (other[i] !== you[i]) return false;
            return true;
        }

        /* Build random tree with shortcuts */
        function buildRandomGraph(nodeCount, extraCount, maxDepth, rng) {
            const nodes = [];
            const root = { id: 0, address: [0], parent: null, children: [], extraConnections: [] };
            nodes.push(root);

            for (let i = 1; i < nodeCount; i++) {
                const available = nodes.filter(n => n.address.length < maxDepth && n.children.length < 4);
                if (!available.length) break;
                const parent = available[Math.floor(rng() * available.length)];
                const address = parent.address.concat([parent.children.length]);
                const node = { id: i, address, parent: parent.id, children: [], extraConnections: [] };
                parent.children.push(i);
                nodes.push(node);
            }

            let attempts = 0;
            for (let i = 0; i < extraCount && attempts < extraCount * 400; i++) {
                attempts++;
                const a = Math.floor(rng() * nodes.length);
                const b = Math.floor(rng() * nodes.length);
                if (a === b) continue;
                const A = nodes[a], B = nodes[b];
                if (A.parent === b || B.parent === a) continue;
                if (A.children.includes(b) || B.children.includes(a)) continue;
                if (A.extraConnections.includes(b)) continue;
                if (Math.abs(A.address.length - B.address.length) < 2) continue;
                A.extraConnections.push(b);
                B.extraConnections.push(a);
            }

            const adj = new Array(nodes.length).fill(0).map(() => []);
            nodes.forEach(n => {
                if (n.parent !== null) adj[n.id].push(n.parent);
                n.children.forEach(c => adj[n.id].push(c));
                n.extraConnections.forEach(e => adj[n.id].push(e));
            });

            nodes.forEach(n => {
                n.connections = [];
                if (n.parent !== null) n.connections.push({ address: nodes[n.parent].address.slice(), to: n.parent });
                n.children.forEach(c => n.connections.push({ address: nodes[c].address.slice(), to: c }));
                n.extraConnections.forEach(e => n.connections.push({ address: nodes[e].address.slice(), to: e }));
            });

            return { nodes, adj };
        }

        /* BFS */
        function bfs(adj, start, goal) {
            const visited = new Array(adj.length).fill(false);
            const parent = new Array(adj.length).fill(-1);
            const q = [start];
            visited[start] = true;
            let head = 0;
            let ops = 0;
            while (head < q.length) {
                const u = q[head++];
                if (u === goal) break;
                for (const v of adj[u]) {
                    ops++;
                    if (!visited[v]) {
                        visited[v] = true;
                        parent[v] = u;
                        q.push(v);
                    }
                }
            }
            if (!visited[goal]) return { success: false, ops };
            let hops = 0;
            for (let cur = goal; cur !== start; cur = parent[cur]) hops++;
            return { success: true, hops, ops };
        }

        /* Dijkstra (unit weights) */
        class MinPQ { constructor() { this._arr = []; } push(item, prio) { this._arr.push({ item, prio }); this._arr.sort((a, b) => a.prio - b.prio); } pop() { return this._arr.length ? this._arr.shift().item : null; } isEmpty() { return this._arr.length === 0; } }
        function dijkstra(adj, start, goal) {
            const n = adj.length;
            const dist = new Array(n).fill(Infinity);
            const prev = new Array(n).fill(-1);
            const pq = new MinPQ();
            let ops = 0;
            dist[start] = 0;
            pq.push(start, 0);
            while (!pq.isEmpty()) {
                const u = pq.pop();
                if (u === goal) break;
                for (const v of adj[u]) {
                    ops++;
                    const nd = dist[u] + 1;
                    if (nd < dist[v]) {
                        dist[v] = nd;
                        prev[v] = u;
                        pq.push(v, nd);
                    }
                }
            }
            if (!isFinite(dist[goal])) return { success: false, ops };
            let hops = 0;
            for (let cur = goal; cur !== start; cur = prev[cur]) hops++;
            return { success: true, hops, ops };
        }

        /* A* */
        function prefixLength(a, b) {
            const m = Math.min(a.length, b.length);
            let i = 0;
            while (i < m && a[i] === b[i]) i++;
            return i;
        }
        function aStar(adj, nodes, start, goal) {
            const n = adj.length;
            const g = new Array(n).fill(Infinity);
            const f = new Array(n).fill(Infinity);
            const prev = new Array(n).fill(-1);
            const open = new MinPQ();
            let ops = 0;
            function heuristic(u) {
                const common = prefixLength(nodes[u].address, nodes[goal].address);
                const estimate = Math.max(0, nodes[goal].address.length - common);
                return estimate;
            }
            g[start] = 0;
            f[start] = heuristic(start);
            open.push(start, f[start]);
            while (!open.isEmpty()) {
                const u = open.pop();
                if (u === goal) break;
                for (const v of adj[u]) {
                    ops++;
                    const tentative_g = g[u] + 1;
                    if (tentative_g < g[v]) {
                        g[v] = tentative_g;
                        prev[v] = u;
                        f[v] = g[v] + heuristic(v);
                        open.push(v, f[v]);
                    }
                }
            }
            if (!isFinite(g[goal])) return { success: false, ops };
            let hops = 0;
            for (let cur = goal; cur !== start; cur = prev[cur]) hops++;
            return { success: true, hops, ops };
        }

        /* LHRP send */
        function nodeSend_LHRP(node, nodes, pocketAddress) {
            if (!node.connections || node.connections.length === 0) return null;
            if (eqAddr(node.address, pocketAddress)) return null;
            let best = node.connections[0];
            let bestIdx = matchIndex(prefixMatch(best.address, pocketAddress));
            let bestLen = best.address.length;
            const directChild = isChildren(pocketAddress, node.address);
            for (let i = 1; i < node.connections.length; i++) {
                const c = node.connections[i];
                const idx = matchIndex(prefixMatch(c.address, pocketAddress));
                const len = c.address.length;
                if (idx > bestIdx || (idx === bestIdx && len > bestLen)) {
                    best = c;
                    bestIdx = idx;
                    bestLen = len;
                }
            }
            if (directChild && !isChildren(best.address, node.address)) return null;
            return best.to;
        }
        function lhrpRoute(nodes, adj, start, goal, maxHops) {
            let current = start;
            const visited = new Set();
            let hops = 0, ops = 0;
            while (current !== goal) {
                if (visited.has(current)) return { success: false, hops: null, ops };
                visited.add(current);
                const node = nodes[current];
                const next = nodeSend_LHRP(node, nodes, nodes[goal].address);
                ops += node.connections ? node.connections.length : 0;
                if (next === null) return { success: false, hops: null, ops };
                current = next;
                hops++;
                if (hops > maxHops) return { success: false, hops: null, ops };
            }
            return { success: true, hops, ops };
        }

        /* Stats helpers */
        function mean(arr) { if (!arr.length) return null; return arr.reduce((a, b) => a + b, 0) / arr.length; }
        function median(arr) { if (!arr.length) return null; const s = arr.slice().sort((a, b) => a - b); const m = Math.floor(s.length / 2); return s.length % 2 ? s[m] : (s[m - 1] + s[m]) / 2; }
        function percentile(arr, p) { if (!arr.length) return null; const s = arr.slice().sort((a, b) => a - b); const idx = Math.max(0, Math.min(s.length - 1, Math.ceil((p / 100) * s.length) - 1)); return s[idx]; }
        function histogram(arr, buckets = 10) {
            if (!arr.length) return [];
            const s = arr.slice().sort((a, b) => a - b);
            const min = s[0], max = s[s.length - 1];
            if (min === max) return [{ range: `${min}`, count: s.length }];
            const size = (max - min) / buckets;
            const out = [];
            for (let i = 0; i < buckets; i++) out.push({ min: Math.round(min + i * size), max: Math.round(min + (i + 1) * size), count: 0 });
            for (const v of s) {
                let idx = Math.floor((v - min) / size);
                if (idx === buckets) idx = buckets - 1;
                out[idx].count++;
            }
            return out.map(b => ({ range: `${b.min}–${b.max}`, count: b.count }));
        }

        /* Comparison routine */
        function vergleiche(trials, nodeCount, extra, maxDepth, selectedAlgs, maxHops, rng, progressCb) {
            const { nodes, adj } = buildRandomGraph(nodeCount, extra, maxDepth, rng);
            const stats = { network: { nodes: nodes.length, extraEdges: extra, maxDepth }, trials, algorithms: {} };

            const collectors = {};
            for (const alg of selectedAlgs) {
                collectors[alg] = { successes: 0, failures: 0, hops: [], ops: [], opsPerTrial: [], perTrial: [] };
            }

            for (let i = 0; i < trials; i++) {
                if (i % 50 === 0 && progressCb) progressCb(i / trials);

                let a = Math.floor(rng() * nodes.length);
                let b = Math.floor(rng() * nodes.length);
                if (a === b) { i--; continue; }

                if (selectedAlgs.includes('bfs')) {
                    const r = bfs(adj, a, b);
                    collectors['bfs'].opsPerTrial.push(r.ops);
                    collectors['bfs'].perTrial.push({ start: a, goal: b, success: r.success, hops: r.hops, ops: r.ops });
                    collectors['bfs'].ops.push(r.ops);
                    if (r.success) { collectors['bfs'].successes++; collectors['bfs'].hops.push(r.hops); } else collectors['bfs'].failures++;
                }
                if (selectedAlgs.includes('dijkstra')) {
                    const r = dijkstra(adj, a, b);
                    collectors['dijkstra'].opsPerTrial.push(r.ops);
                    collectors['dijkstra'].perTrial.push({ start: a, goal: b, success: r.success, hops: r.hops, ops: r.ops });
                    collectors['dijkstra'].ops.push(r.ops);
                    if (r.success) { collectors['dijkstra'].successes++; collectors['dijkstra'].hops.push(r.hops); } else collectors['dijkstra'].failures++;
                }
                if (selectedAlgs.includes('astar')) {
                    const r = aStar(adj, nodes, a, b);
                    collectors['astar'].opsPerTrial.push(r.ops);
                    collectors['astar'].perTrial.push({ start: a, goal: b, success: r.success, hops: r.hops, ops: r.ops });
                    collectors['astar'].ops.push(r.ops);
                    if (r.success) { collectors['astar'].successes++; collectors['astar'].hops.push(r.hops); } else collectors['astar'].failures++;
                }
                if (selectedAlgs.includes('lhrp')) {
                    const r = lhrpRoute(nodes, adj, a, b, maxHops);
                    collectors['lhrp'].opsPerTrial.push(r.ops);
                    collectors['lhrp'].perTrial.push({ start: a, goal: b, success: r.success, hops: r.hops, ops: r.ops });
                    collectors['lhrp'].ops.push(r.ops);
                    if (r.success) { collectors['lhrp'].successes++; collectors['lhrp'].hops.push(r.hops); } else collectors['lhrp'].failures++;
                }
            }

            for (const alg of selectedAlgs) {
                const c = collectors[alg];
                const successCount = c.successes;
                const totalTrials = trials;
                stats.algorithms[alg] = {
                    successRate: successCount / totalTrials,
                    successCount: successCount,
                    failureCount: c.failures,
                    avgHop: successCount ? mean(c.hops) : null,
                    medianHop: successCount ? median(c.hops) : null,
                    p90Hop: successCount ? percentile(c.hops, 90) : null,
                    hopHistogram: successCount ? histogram(c.hops, 8) : [],
                    avgOpsPerTrial: mean(c.opsPerTrial),
                    avgOpsOnSuccess: c.hops.length ? mean(c.ops.filter((_, i) => c.perTrial[i] && c.perTrial[i].success)) : mean(c.ops),
                    raw: c
                };
            }

            const nodeDegrees = adj.map(a => a.length);
            stats.network.avgDegree = nodeDegrees.reduce((a, b) => a + b, 0) / nodeDegrees.length;
            stats.network.minDegree = Math.min(...nodeDegrees);
            stats.network.maxDegree = Math.max(...nodeDegrees);

            // include nodes/adj for debugging if needed (omitted by default)
            return stats;
        }

        /* Format result to requested shape */
        function round3(x) { return (x == null) ? null : Number(x.toFixed(3)); }
        function formatOutput(stats) {
            const out = {
                network: {
                    nodes: stats.network.nodes,
                    extraEdges: stats.network.extraEdges,
                    maxDepth: stats.network.maxDepth,
                    avgDegree: round3(stats.network.avgDegree)
                },
                trials: stats.trials,
                algorithms: {},
                duration_seconds: round3(stats.duration_seconds || 0)
            };

            for (const alg of Object.keys(stats.algorithms)) {
                const s = stats.algorithms[alg];
                out.algorithms[alg] = {
                    successRate: round3(s.successRate),
                    avgHop: s.avgHop == null ? null : round3(s.avgHop),
                    avgOps: s.avgOpsPerTrial == null ? null : round3(s.avgOpsPerTrial)
                };
            }

            return out;
        }

        /* UI */
        const runBtn = document.getElementById('runBtn');
        const exportCSV = document.getElementById('exportCSV');
        const showRaw = document.getElementById('showRaw');
        const showHist = document.getElementById('showHist');
        const summary = document.getElementById('summary');
        const extraOutput = document.getElementById('extraOutput');
        const progressBar = document.querySelector('.progress');
        const progressFill = document.querySelector('.progress > i');

        let lastResult = null; // raw stats
        let formattedResult = null;

        runBtn.addEventListener('click', () => {
            const trials = Math.max(1, parseInt(document.getElementById("trials").value) || 2000);
            const nodes = Math.max(2, parseInt(document.getElementById("nodes").value) || 200);
            const extras = Math.max(0, parseInt(document.getElementById("extras").value) || 60);
            const depth = Math.max(1, parseInt(document.getElementById("depth").value) || 6);
            const maxhops = Math.max(1, parseInt(document.getElementById("maxhops").value) || 300);
            const seedVal = document.getElementById("seed").value;
            const seed = seedVal === "" ? null : Number(seedVal);
            const rng = mkRNG(seed);
            const checks = Array.from(document.querySelectorAll('.alg')).filter(c => c.checked).map(c => c.value);
            if (!checks.length) { summary.textContent = "Bitte mindestens einen Algorithmus auswählen."; return; }

            runBtn.disabled = true;
            extraOutput.textContent = '';
            summary.textContent = "Berechnung läuft...";
            progressBar.style.display = 'block';
            progressFill.style.width = '0%';

            setTimeout(() => {
                try {
                    const start = performance.now();
                    let lastProg = 0;
                    const stats = vergleiche(trials, nodes, extras, depth, checks, maxhops, rng, (p) => {
                        lastProg = Math.max(lastProg, p);
                        progressFill.style.width = `${Math.round(lastProg * 100)}%`;
                    });
                    const dur = (performance.now() - start) / 1000;
                    stats.duration_seconds = dur;
                    lastResult = stats;
                    formattedResult = formatOutput(stats);

                    // display the formatted JSON exactly as requested
                    summary.textContent = JSON.stringify(formattedResult, null, 2);

                    progressFill.style.width = '100%';
                    runBtn.disabled = false;
                    progressBar.style.display = 'none';
                } catch (e) {
                    summary.textContent = "Fehler: " + e.toString();
                    runBtn.disabled = false;
                    progressBar.style.display = 'none';
                }
            }, 30);
        });

        showRaw.addEventListener('click', () => {
            if (!lastResult) { extraOutput.textContent = "Kein Ergebnis zum Anzeigen."; return; }
            extraOutput.textContent = JSON.stringify(lastResult, null, 2);
        });

        showHist.addEventListener('click', () => {
            if (!lastResult) { extraOutput.textContent = "Kein Ergebnis zum Anzeigen."; return; }
            const parts = [];
            for (const alg of Object.keys(lastResult.algorithms)) {
                const a = lastResult.algorithms[alg];
                parts.push(`== ${alg.toUpperCase()} ==`);
                if (!a.hopHistogram || !a.hopHistogram.length) { parts.push('  Keine erfolgreichen Pfade (keine Histogrammdaten)'); continue; }
                for (const b of a.hopHistogram) {
                    parts.push(`  ${b.range.padEnd(12)} | ${b.count}`);
                }
                parts.push('');
            }
            extraOutput.textContent = parts.join('\n');
        });

        /* CSV Export uses raw perTrial stored in lastResult.algorithms[alg].raw.perTrial */
        exportCSV.addEventListener('click', () => {
            if (!lastResult) { extraOutput.textContent = "Kein Ergebnis zum Exportieren."; return; }
            const algs = Object.keys(lastResult.algorithms);
            const samplesAlg = algs[0];
            const raw = lastResult.algorithms[samplesAlg].raw;
            if (!raw || !raw.perTrial) {
                extraOutput.textContent = "Rohdaten nicht verfügbar für CSV-Export.";
                return;
            }
            const trials = raw.perTrial.length;
            const rows = [];
            rows.push(['trial', 'start', 'goal', 'algorithm', 'success', 'hops', 'ops'].join(','));
            for (let i = 0; i < trials; i++) {
                for (const alg of algs) {
                    const r = lastResult.algorithms[alg].raw.perTrial[i] || { start: '', goal: '', success: false, hops: '', ops: '' };
                    rows.push([i, r.start, r.goal, alg, r.success ? 1 : 0, r.hops == null ? '' : r.hops, r.ops == null ? '' : r.ops].join(','));
                }
            }
            const csv = rows.join('\n');
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `lhpr_compare_${Date.now()}.csv`;
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);
        });
    </script>

</body>

</html>